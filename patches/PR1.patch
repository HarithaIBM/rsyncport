diff --git a/Makefile.in b/Makefile.in
index 7c75c26..6413224 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -53,7 +53,7 @@ popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 	popt/popthelp.o popt/poptparse.o popt/poptint.o
 OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) @BUILD_ZLIB@ @BUILD_POPT@
 
-TLS_OBJ = tls.o syscall.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/permstring.o lib/sysxattrs.o @BUILD_POPT@
+TLS_OBJ = tls.o syscall.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/permstring.o lib/sysxattrs.o $(OBJS)
 
 # Programs we must have to run the test cases
 CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) getfsdev$(EXEEXT) \
@@ -172,7 +172,7 @@ getfsdev$(EXEEXT): getfsdev.o
 
 TRIMSLASH_OBJ = trimslash.o syscall.o util2.o t_stub.o lib/compat.o lib/snprintf.o
 trimslash$(EXEEXT): $(TRIMSLASH_OBJ)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(TRIMSLASH_OBJ) $(LIBS)
 
 T_UNSAFE_OBJ = t_unsafe.o syscall.o util1.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/wildmatch.o
 t_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)
diff --git a/compat.c b/compat.c
index 4ce8c6d..24b30df 100644
--- a/compat.c
+++ b/compat.c
@@ -47,6 +47,9 @@ extern int preserve_atimes;
 extern int preserve_crtimes;
 extern int preserve_acls;
 extern int preserve_xattrs;
+#ifdef __MVS__
+extern int preserve_zos_tags;
+#endif
 extern int xfer_flags_as_varint;
 extern int need_messages_from_generator;
 extern int delete_mode, delete_before, delete_during, delete_after;
@@ -54,6 +57,7 @@ extern int do_compression;
 extern int do_compression_level;
 extern int saw_stderr_opt;
 extern int msgs2stderr;
+extern int verbose;
 extern char *shell_cmd;
 extern char *partial_dir;
 extern char *files_from;
@@ -87,6 +91,9 @@ int xattr_sum_len = 0;
 
 /* These index values are for the file-list's extra-attribute array. */
 int pathname_ndx, depth_ndx, atimes_ndx, crtimes_ndx, uid_ndx, gid_ndx, acls_ndx, xattrs_ndx, unsort_ndx;
+#ifdef __MVS__
+int zos_tags_ndx = 0;
+#endif
 
 int receiver_symlink_times = 0; /* receiver can set the time on a symlink */
 int sender_symlink_iconv = 0;	/* sender should convert symlink content */
@@ -122,7 +129,7 @@ struct name_num_obj valid_compressions = {
 #define CF_CHKSUM_SEED_FIX (1<<5)
 #define CF_INPLACE_PARTIAL_DIR (1<<6)
 #define CF_VARINT_FLIST_FLAGS (1<<7)
-#define CF_ID0_NAMES (1<<8)
+
 
 static const char *client_info;
 
@@ -592,6 +599,10 @@ void setup_protocol(int f_out,int f_in)
 		acls_ndx = ++file_extra_cnt;
 	if (preserve_xattrs)
 		xattrs_ndx = ++file_extra_cnt;
+#ifdef __MVS__
+	if (preserve_zos_tags)
+		zos_tags_ndx = (file_extra_cnt += 2); /* Need 2 slots: ccsid + txtflag */
+#endif
 
 	if (am_server)
 		set_allow_inc_recurse();
@@ -599,8 +610,13 @@ void setup_protocol(int f_out,int f_in)
 	if (remote_protocol == 0) {
 		if (am_server && !local_server)
 			check_sub_protocol();
-		if (!read_batch)
+		if (!read_batch) {
+#ifdef __MVS__
 			write_int(f_out, protocol_version);
+#else
+			write_int(f_out, protocol_version);
+#endif
+		}
 		remote_protocol = read_int(f_in);
 		if (protocol_version > remote_protocol)
 			protocol_version = remote_protocol;
@@ -726,6 +742,10 @@ void setup_protocol(int f_out,int f_in)
 				compat_flags |= CF_INPLACE_PARTIAL_DIR;
 			if (strchr(client_info, 'u') != NULL)
 				compat_flags |= CF_ID0_NAMES;
+#ifdef __MVS__
+			if (strchr(client_info, 'Z') != NULL && preserve_zos_tags)
+				compat_flags |= CF_ZOS_TAGS;
+#endif
 			if (strchr(client_info, 'v') != NULL) {
 				do_negotiated_strings = 1;
 				compat_flags |= CF_VARINT_FLIST_FLAGS;
@@ -805,6 +825,49 @@ void setup_protocol(int f_out,int f_in)
 	}
 #endif
 
+#ifdef __MVS__
+	/*
+	 * Check negotiated flags for z/OS tag support.
+	 * This MUST be done after compat_flags are exchanged.
+	 * If auto-detect (2) or explicit (1) but remote didn't confirm,
+	 * disable tags and clean up slots.
+	 */
+	if (verbose > 2) {
+		rprintf(FINFO, "[DEBUG] Checking z/OS tags negotiation. protocol_version=%d, compat_flags=0x%x, CF_ZOS_TAGS=0x%x, preserve_zos_tags=%d\n",
+			protocol_version, compat_flags, CF_ZOS_TAGS, preserve_zos_tags);
+	}
+
+	if (protocol_version >= 30) {
+		if (compat_flags & CF_ZOS_TAGS) {
+			if (verbose > 2) rprintf(FINFO, "[DEBUG] z/OS tags negotiated successfully.\n");
+			if (preserve_zos_tags == 2)
+				preserve_zos_tags = 1;
+		} else {
+			if (verbose > 2) rprintf(FINFO, "[DEBUG] z/OS tags NOT negotiated.\n");
+			if (preserve_zos_tags == 1) {
+				rprintf(FWARNING, "Remote does not support z/OS tags. Tags will not be preserved.\n");
+			}
+			preserve_zos_tags = 0;
+			/* Back out the slots reserved for z/OS tags. */
+			if (zos_tags_ndx) {
+				if (verbose > 2) rprintf(FINFO, "[DEBUG] Backing out z/OS tag slots.\n");
+				file_extra_cnt -= 2;
+				zos_tags_ndx = 0;
+			}
+		}
+	} else {
+		if (verbose > 2) rprintf(FINFO, "[DEBUG] Protocol version < 30, z/OS tags disabled.\n");
+		/* Pre-30 does not support this negotiation. Assume NO tags unless user forced it (which might fail). */
+		if (preserve_zos_tags == 2) {
+			preserve_zos_tags = 0;
+			if (zos_tags_ndx) {
+				file_extra_cnt -= 2;
+				zos_tags_ndx = 0;
+			}
+		}
+	}
+#endif
+
 	negotiate_the_strings(f_in, f_out);
 
 	if (am_server) {
diff --git a/flist.c b/flist.c
index 1783253..6441b5f 100644
--- a/flist.c
+++ b/flist.c
@@ -48,6 +48,10 @@ extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_acls;
 extern int preserve_xattrs;
+#ifdef __MVS__
+extern int preserve_zos_tags;
+extern int zos_default_ccsid;
+#endif
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_devices;
@@ -57,6 +61,9 @@ extern int missing_args;
 extern int eol_nulls;
 extern int atimes_ndx;
 extern int crtimes_ndx;
+#ifdef __MVS__
+extern int zos_tags_ndx;
+#endif
 extern int relative_paths;
 extern int implied_dirs;
 extern int ignore_perishable;
@@ -500,6 +507,15 @@ static void send_file_entry(int f, const char *fname, struct file_struct *file,
 	}
 #endif
 
+#ifdef __MVS__
+	if (DEBUG_GTE(FLIST, 2)) {
+		rprintf(FINFO, "[DEBUG] send_file_entry: preserve_zos_tags=%d, zos_tags_ndx=%d, mode=%o, S_ISREG=%d\n",
+			preserve_zos_tags, zos_tags_ndx, mode, S_ISREG(mode));
+	}
+	if (preserve_zos_tags && S_ISREG(mode))
+		xflags |= XMIT_ZOS_TAGS;
+#endif
+
 #ifdef SUPPORT_HARD_LINKS
 	if (tmp_dev != -1) {
 		if (protocol_version >= 30) {
@@ -659,6 +675,13 @@ static void send_file_entry(int f, const char *fname, struct file_struct *file,
 	}
 #endif
 
+#ifdef __MVS__
+	if (xflags & XMIT_ZOS_TAGS) {
+		write_varint(f, F_ZOS_CCSID(file));
+		write_varint(f, F_ZOS_TXTFLAG(file));
+	}
+#endif
+
 	if (always_checksum && (S_ISREG(mode) || protocol_version < 28)) {
 		const char *sum;
 		if (S_ISREG(mode))
@@ -694,6 +717,10 @@ static struct file_struct *recv_file_entry(int f, struct file_list *flist, int x
 	static uid_t uid;
 	static gid_t gid;
 	static uint16 gid_flags;
+#ifdef __MVS__
+	static unsigned short zos_ccsid;
+	static unsigned int zos_txtflag;
+#endif
 	static char lastname[MAXPATHLEN], *lastdir;
 	static int lastdir_depth, lastdir_len = -1;
 	static unsigned int del_hier_name_len = 0;
@@ -946,6 +973,21 @@ static struct file_struct *recv_file_entry(int f, struct file_list *flist, int x
 #endif
 		linkname_len = 0;
 
+#ifdef __MVS__
+	/* Read z/OS tags if present */
+	if (xflags & XMIT_ZOS_TAGS) {
+		zos_ccsid = read_varint(f);
+		zos_txtflag = read_varint(f);
+		if (preserve_zos_tags && zos_tags_ndx)
+			extra_len += 2 * EXTRA_LEN;
+	} else if (preserve_zos_tags && zos_tags_ndx && S_ISREG(mode)) {
+		/* Linux -> z/OS: default to ISO8859-1 */
+		zos_ccsid = zos_default_ccsid;
+		zos_txtflag = 1;
+		extra_len += 2 * EXTRA_LEN;
+	}
+#endif
+
 	if (copy_devices && IS_DEVICE(mode)) {
 		/* This is impossible in the official release, but some pre-release patches
 		 * didn't convert the device into a file before sending, so we'll do it here
@@ -1071,6 +1113,12 @@ static struct file_struct *recv_file_entry(int f, struct file_list *flist, int x
 #endif
 	if (unsort_ndx)
 		F_NDX(file) = flist->used + flist->ndx_start;
+#ifdef __MVS__
+	if (zos_tags_ndx && S_ISREG(mode)) {
+		F_ZOS_CCSID(file) = zos_ccsid;
+		F_ZOS_TXTFLAG(file) = zos_txtflag;
+	}
+#endif
 
 	if (basename != thisname) {
 		file->dirname = lastdir;
@@ -1482,6 +1530,12 @@ struct file_struct *make_file(const char *fname, struct file_list *flist,
 	if (crtimes_ndx)
 		F_CRTIME(file) = get_create_time(fname, &st);
 #endif
+#ifdef __MVS__
+	if (zos_tags_ndx && S_ISREG(st.st_mode)) {
+		F_ZOS_CCSID(file) = st.st_tag.ft_ccsid;
+		F_ZOS_TXTFLAG(file) = st.st_tag.ft_txtflag;
+	}
+#endif
 
 	if (basename != thisname)
 		file->dirname = lastdir;
diff --git a/mkproto.awk b/mkproto.awk
index bd2e927..49e4309 100644
--- a/mkproto.awk
+++ b/mkproto.awk
@@ -36,5 +36,5 @@ inheader {
 
 END {
     if (old_protos != protos) print protos > "proto.h"
-    system("touch proto.h-tstamp")
+    system("touch proto.h-tstamp && chtag -tcISO8859-1 proto.h-tstamp")
 }
diff --git a/options.c b/options.c
index 578507c..e0fdf0c 100644
--- a/options.c
+++ b/options.c
@@ -57,6 +57,10 @@ int preserve_acls = 0;
 int preserve_xattrs = 0;
 int preserve_perms = 0;
 int preserve_executability = 0;
+#ifdef __MVS__
+int preserve_zos_tags = 2;  /* Auto-detect by default on z/OS */
+int zos_default_ccsid = 819; /* ISO8859-1/ASCII by default */
+#endif
 int preserve_devices = 0;
 int preserve_specials = 0;
 int preserve_uid = 0;
@@ -630,6 +634,11 @@ static struct poptOption long_options[] = {
   {"xattrs",          'X', POPT_ARG_NONE,   0, 'X', 0, 0 },
   {"no-xattrs",        0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
   {"no-X",             0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
+#ifdef __MVS__
+  {"zos-tags",         0,  POPT_ARG_VAL,    &preserve_zos_tags, 1, 0, 0 },
+  {"no-zos-tags",      0,  POPT_ARG_VAL,    &preserve_zos_tags, 0, 0, 0 },
+  {"zos-default-ccsid",0,  POPT_ARG_INT,    &zos_default_ccsid, 0, 0, 0 },
+#endif
   {"times",           't', POPT_ARG_VAL,    &preserve_mtimes, 1, 0, 0 },
   {"no-times",         0,  POPT_ARG_VAL,    &preserve_mtimes, 0, 0, 0 },
   {"no-t",             0,  POPT_ARG_VAL,    &preserve_mtimes, 0, 0, 0 },
@@ -3032,6 +3041,11 @@ int maybe_add_e_option(char *buf, int buf_len)
 		buf[x++] = 'I'; /* support inplace_partial behavior */
 		buf[x++] = 'v'; /* use varint for flist & compat flags; negotiate checksum */
 		buf[x++] = 'u'; /* include name of uid 0 & gid 0 in the id map */
+#ifdef __MVS__
+		/* Signal z/OS tag support to the server */
+		if (preserve_zos_tags)
+			buf[x++] = 'Z';
+#endif
 
 		/* NOTE: Avoid using 'V' -- it was represented with the high bit of a write_byte() that became a write_varint(). */
 	}
diff --git a/pipe.c b/pipe.c
index 3e5f038..b6b962f 100644
--- a/pipe.c
+++ b/pipe.c
@@ -93,6 +93,12 @@ pid_t piped_child(char **command, int *f_in, int *f_out)
 	*f_in = from_child_pipe[0];
 	*f_out = to_child_pipe[1];
 
+#ifdef __MVS__
+  struct f_cnvrt cvtreq = {SETCVTON, 0, 1047};
+  fcntl(*f_in, F_CONTROL_CVT, &cvtreq);
+  fcntl(*f_out, F_CONTROL_CVT, &cvtreq);
+#endif
+
 	return pid;
 }
 
@@ -174,5 +180,11 @@ pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
 	*f_in = from_child_pipe[0];
 	*f_out = to_child_pipe[1];
 
+#ifdef __MVS__
+  struct f_cnvrt cvtreq = {SETCVTON, 0, 819};
+  fcntl(*f_in, F_CONTROL_CVT, &cvtreq);
+  fcntl(*f_out, F_CONTROL_CVT, &cvtreq);
+#endif
+
 	return pid;
 }
diff --git a/popt/findme.c b/popt/findme.c
index 49fc9f6..83b7531 100644
--- a/popt/findme.c
+++ b/popt/findme.c
@@ -6,6 +6,7 @@
    file accompanying popt source distributions, available from 
    ftp://ftp.rpm.org/pub/rpm/dist. */
 
+#include <unistd.h>
 #include "system.h"
 #include "findme.h"
 
diff --git a/rsync.c b/rsync.c
index b130aba..6a4680c 100644
--- a/rsync.c
+++ b/rsync.c
@@ -26,11 +26,18 @@
 #elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
 #include <langinfo.h>
 #endif
+#ifdef __MVS__
+#include <fcntl.h>
+#endif
 
 extern int dry_run;
 extern int preserve_acls;
 extern int preserve_xattrs;
 extern int preserve_perms;
+#ifdef __MVS__
+extern int preserve_zos_tags;
+extern int zos_tags_ndx;
+#endif
 extern int preserve_executability;
 extern int preserve_mtimes;
 extern int omit_dir_times;
@@ -669,12 +676,54 @@ int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
 	}
 #endif
 
+#ifdef __MVS__
+	if (preserve_zos_tags && zos_tags_ndx && S_ISREG(file->mode)) {
+		unsigned short ccsid = F_ZOS_CCSID(file);
+		unsigned int txtflag = F_ZOS_TXTFLAG(file);
+
+		/* Check if tags need to be updated */
+		if (ccsid != sxp->st.st_tag.ft_ccsid || txtflag != sxp->st.st_tag.ft_txtflag) {
+			attrib_t attr;
+			memset(&attr, 0, sizeof(attr));
+			attr.att_filetagchg = 1;
+			attr.att_filetag.ft_ccsid = ccsid;
+			attr.att_filetag.ft_txtflag = txtflag;
+
+			if (__chattr(fname, &attr, sizeof(attr)) == 0) {
+				updated |= UPDATED_MODE; /* Use existing flag for tracking */
+				if (DEBUG_GTE(OWN, 1)) {
+					rprintf(FINFO, "set z/OS tags on %s: ccsid=%u txtflag=%u\n",
+						fname, ccsid, txtflag);
+				}
+			} else {
+				rsyserr(FERROR_XFER, errno, "failed to set z/OS tags on %s", full_fname(fname));
+			}
+		}
+	}
+#endif
+
 	if (INFO_GTE(NAME, 2) && flags & ATTRS_REPORT) {
 		if (updated)
 			rprintf(FCLIENT, "%s\n", fname);
 		else
 			rprintf(FCLIENT, "%s is uptodate\n", fname);
 	}
+
+#ifdef __MVS__
+	/* Set z/OS file tags if enabled and file is regular */
+	if (zos_tags_ndx && S_ISREG(new_mode)) {
+		attrib_t attr;
+		memset(&attr, 0, sizeof(attr));
+		attr.att_filetagchg = 1;
+		attr.att_filetag.ft_ccsid = F_ZOS_CCSID(file);
+		attr.att_filetag.ft_txtflag = F_ZOS_TXTFLAG(file);
+
+		if (__chattr(fname, &attr, sizeof(attr)) != 0) {
+			rsyserr(FERROR_XFER, errno, "failed to set file tags on %s", full_fname(fname));
+		}
+	}
+#endif
+
   cleanup:
 	if (sxp == &sx2)
 		free_stat_x(&sx2);
diff --git a/rsync.h b/rsync.h
index 479ac48..de5fdea 100644
--- a/rsync.h
+++ b/rsync.h
@@ -69,8 +69,15 @@
 
 /* The following XMIT flags require an rsync that uses a varint for the flag values */
 
-#define XMIT_RESERVED_16 (1<<16) 	/* reserved for future fileflags use */
-#define XMIT_CRTIME_EQ_MTIME (1<<17)	/* any protocol - restricted by command-line option */
+#define XMIT_RESERVED_16 (1<<16)       /* reserved for future fileflags use */
+
+#define XMIT_CRTIME_EQ_MTIME (1<<17)   /* any protocol - restricted by command-line option */
+
+#define XMIT_ZOS_TAGS (1<<18)          /* z/OS file tag attributes (CCSID, txtflag) */
+
+
+
+#define PROTOCOL_ZOS_TAGS (1<<30)      /* Capability flag for z/OS tags in protocol version */
 
 /* These flags are used in the live flist data. */
 
@@ -169,6 +176,9 @@
 #define IOERR_VANISHED	(1<<1)
 #define IOERR_DEL_LIMIT (1<<2)
 
+#define CF_ID0_NAMES (1<<8)
+#define CF_ZOS_TAGS  (1<<29)    /* z/OS file tag support negotiation */
+
 #define MAX_ARGS 1000
 #define MAX_BASIS_DIRS 20
 #define MAX_SERVER_ARGS (MAX_BASIS_DIRS*2 + 100)
@@ -317,6 +327,8 @@ enum delret {
 #include "config.h"
 
 /* The default RSYNC_RSH is always set in config.h. */
+# include <sys/stat.h>
+#include <dirent.h>
 
 #include <stdio.h>
 #ifdef HAVE_SYS_TYPES_H
@@ -444,6 +456,13 @@ enum delret {
 #endif
 #endif
 
+#ifdef HAVE_SYS_MODES_H
+/* apparently z/OS needs this for S_ISLNK */
+#ifndef S_ISLNK
+#include <sys/modes.h>
+#endif
+#endif
+
 /* these are needed for the uid/gid mapping code */
 #include <pwd.h>
 #include <grp.h>
@@ -459,6 +478,8 @@ enum delret {
 #include <sys/file.h>
 #endif
 
+#define HAVE_DIRENT_H 1
+
 #ifdef HAVE_DIRENT_H
 # include <dirent.h>
 #else
@@ -483,6 +504,13 @@ enum delret {
 #include <sys/sysmacros.h>
 #endif
 
+#ifdef __MVS__
+  /* z/OS has no 'makedev' so create trivial services */
+  #define makedev(devmajor,devminor) ((dev_t)((devmajor) << 24 | (devminor)))
+  #define minor(dev)                 ((dev) & 0xFFFFFF)
+  #define major(dev)                 (((uint32)(dev)) >> 24)
+#endif
+
 #ifdef MAKEDEV_TAKES_3_ARGS
 #define MAKEDEV(devmajor,devminor) makedev(0,devmajor,devminor)
 #else
@@ -821,6 +849,9 @@ extern int uid_ndx;
 extern int gid_ndx;
 extern int acls_ndx;
 extern int xattrs_ndx;
+#ifdef __MVS__
+extern int zos_tags_ndx;
+#endif
 extern int file_sum_extra_cnt;
 
 #ifdef USE_FLEXIBLE_ARRAY
@@ -877,6 +908,10 @@ extern int file_sum_extra_cnt;
 #define F_ACL(f) REQ_EXTRA(f, acls_ndx)->num
 #define F_XATTR(f) REQ_EXTRA(f, xattrs_ndx)->num
 #define F_NDX(f) REQ_EXTRA(f, unsort_ndx)->num
+#ifdef __MVS__
+#define F_ZOS_CCSID(f) REQ_EXTRA(f, zos_tags_ndx)->unum
+#define F_ZOS_TXTFLAG(f) REQ_EXTRA(f, zos_tags_ndx + 1)->unum
+#endif
 #define F_ATIME(f) REQ_EXTRA64(f, atimes_ndx)->num
 #define F_CRTIME(f) REQ_EXTRA64(f, crtimes_ndx)->num
 
@@ -1143,6 +1178,10 @@ typedef struct {
 #ifdef SUPPORT_XATTRS
     item_list *xattr;
 #endif
+#ifdef __MVS__
+    unsigned short zos_ccsid;   /* z/OS Coded Character Set ID */
+    unsigned int zos_txtflag;   /* z/OS text flag */
+#endif
 } stat_x;
 
 #define ACL_READY(sx) ((sx).acc_acl != NULL)
@@ -1316,6 +1355,32 @@ extern int errno;
 #define S_ISREG(mode) (((mode) & (_S_IFMT)) == (_S_IFREG))
 #endif
 
+#ifdef __MVS__
+/* z/OS mode conversion functions */
+mode_t to_linux_mode(unsigned int inmode);
+unsigned int to_zos_mode(mode_t inmode);
+
+/*
+ * On z/OS, our do_stat/do_lstat/do_fstat functions convert st_mode to Linux format.
+ * Therefore, we need to redefine the S_IS* macros to work with Linux-format modes.
+ */
+#undef S_IFMT
+#undef S_IFREG
+#undef S_IFDIR
+#undef S_IFLNK
+#undef S_ISREG
+#undef S_ISDIR
+#undef S_ISLNK
+
+#define S_IFMT   0170000
+#define S_IFREG  0100000
+#define S_IFDIR  0040000
+#define S_IFLNK  0120000
+#define S_ISREG(m)  (((m) & S_IFMT) == S_IFREG)
+#define S_ISDIR(m)  (((m) & S_IFMT) == S_IFDIR)
+#define S_ISLNK(m)  (((m) & S_IFMT) == S_IFLNK)
+#endif
+
 /* work out what fcntl flag to use for non-blocking */
 #ifdef O_NONBLOCK
 # define NONBLOCK_FLAG O_NONBLOCK
diff --git a/syscall.c b/syscall.c
index 34a9bba..c4d2694 100644
--- a/syscall.c
+++ b/syscall.c
@@ -81,6 +81,76 @@ struct create_time {
 
 #define RETURN_ERROR_IF_RO_OR_LO RETURN_ERROR_IF(read_only || list_only, EROFS)
 
+#ifdef __MVS__
+#  define LINUX_S_IFIFO	      0010000	/* [XSI] named pipe (fifo) */
+#  define LINUX_S_IFCHR	      0020000	/* [XSI] character special */
+#  define LINUX_S_IFDIR	      0040000	/* [XSI] directory */
+#  define LINUX_S_IFBLK	      0060000   /* [XSI] block special */
+#  define LINUX_S_IFREG	      0100000   /* [XSI] regular */
+#  define LINUX_S_IFLNK	      0120000   /* [XSI] symbolic link */
+#  define LINUX_S_IFSOCK      0140000   /* [XSI] socket */
+
+#  define ZOS_S_IFIFO       0x04000000	/* named pipe (fifo) */
+#  define ZOS_S_IFCHR       0x02000000	/* character special */
+#  define ZOS_S_IFDIR       0x01000000	/* directory */
+#  define ZOS_S_IFBLK       0x06000000	/* block special */
+#  define ZOS_S_IFREG       0x03000000	/* regular */
+#  define ZOS_S_IFLNK       0x05000000	/* symbolic link */
+#  define ZOS_S_IFSOCK      0x07000000  /* socket */
+
+#  define ZOS_S_IFMT        0xFF000000  /* mask */
+
+/*
+ * z/OS has a 'mode_t' that is 32 bits in size, whereas
+ * Linux has a 'mode_t' that is 16 bits in size.
+ * The bottom 3 nibbles are the same, but z/OS uses
+ * the top word for the st_mode parts of mode and
+ * Linux uses the top nibble
+ */
+mode_t
+to_linux_mode(unsigned int inmode)
+{
+  mode_t outmode = (mode_t) (inmode & 0777);
+
+  //rprintf(FINFO, "[DEBUG to_linux_mode] inmode=0x%08x, inmode&ZOS_S_IFMT=0x%08x, ZOS_S_IFREG=0x%08x\n",
+    //      inmode, inmode & ZOS_S_IFMT, ZOS_S_IFREG);
+
+  if ((inmode & ZOS_S_IFMT) == ZOS_S_IFIFO) { outmode |= LINUX_S_IFIFO; }
+  if ((inmode & ZOS_S_IFMT) == ZOS_S_IFCHR) { outmode |= LINUX_S_IFCHR; }
+  if ((inmode & ZOS_S_IFMT) == ZOS_S_IFDIR) { outmode |= LINUX_S_IFDIR; }
+  if ((inmode & ZOS_S_IFMT) == ZOS_S_IFBLK) { outmode |= LINUX_S_IFBLK; }
+  if ((inmode & ZOS_S_IFMT) == ZOS_S_IFREG) {
+    outmode |= LINUX_S_IFREG;
+    //rprintf(FINFO, "[DEBUG to_linux_mode] MATCHED S_IFREG, outmode=0%o\n", outmode);
+  }
+  if ((inmode & ZOS_S_IFMT) == ZOS_S_IFLNK) { outmode |= LINUX_S_IFLNK; }
+  if ((inmode & ZOS_S_IFMT) == ZOS_S_IFSOCK) { outmode |= LINUX_S_IFSOCK; }
+
+  //rprintf(FINFO, "[DEBUG to_linux_mode] final outmode=0%o\n", outmode);
+  return outmode;
+}
+
+unsigned int
+to_zos_mode(mode_t inmode)
+{
+  unsigned int outmode = (unsigned int) (inmode & 0777);
+
+  if (inmode & LINUX_S_IFIFO) { outmode |= ZOS_S_IFIFO; }
+  if (inmode & LINUX_S_IFCHR) { outmode |= ZOS_S_IFCHR; }
+  if (inmode & LINUX_S_IFDIR) { outmode |= ZOS_S_IFDIR; }
+  if (inmode & LINUX_S_IFBLK) { outmode |= ZOS_S_IFBLK; }
+  if (inmode & LINUX_S_IFREG) { outmode |= ZOS_S_IFREG; }
+  if (inmode & LINUX_S_IFLNK) { outmode |= ZOS_S_IFLNK; }
+  if (inmode & LINUX_S_IFSOCK) { outmode |= ZOS_S_IFSOCK; }
+
+  return outmode;
+}
+
+#define to_native_mode(inmode) (to_zos_mode(inmode))
+#else
+#define to_native_mode(inmode) (inmode)
+#endif
+
 int do_unlink(const char *path)
 {
 	if (dry_run) return 0;
@@ -167,7 +237,7 @@ int do_mknod(const char *pathname, mode_t mode, dev_t dev)
 
 	/* For --fake-super, we create a normal file with mode 0600. */
 	if (am_root < 0) {
-		int fd = open(pathname, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR);
+		int fd = open(pathname, O_WRONLY|O_CREAT|O_TRUNC, to_native_mode(S_IWUSR|S_IRUSR));
 		if (fd < 0 || close(fd) < 0)
 			return -1;
 		return 0;
@@ -175,7 +245,7 @@ int do_mknod(const char *pathname, mode_t mode, dev_t dev)
 
 #if !defined MKNOD_CREATES_FIFOS && defined HAVE_MKFIFO
 	if (S_ISFIFO(mode))
-		return mkfifo(pathname, mode);
+		return mkfifo(pathname, to_native_mode(mode));
 #endif
 #if !defined MKNOD_CREATES_SOCKETS && defined HAVE_SYS_UN_H
 	if (S_ISSOCK(mode)) {
@@ -204,7 +274,7 @@ int do_mknod(const char *pathname, mode_t mode, dev_t dev)
 	}
 #endif
 #ifdef HAVE_MKNOD
-	return mknod(pathname, mode, dev);
+	return mknod(pathname, to_native_mode(mode), dev);
 #else
 	return -1;
 #endif
@@ -219,6 +289,7 @@ int do_rmdir(const char *pathname)
 
 int do_open(const char *pathname, int flags, mode_t mode)
 {
+  int fd;
 	if (flags != O_RDONLY) {
 		RETURN_ERROR_IF(dry_run, 0);
 		RETURN_ERROR_IF_RO_OR_LO;
@@ -229,7 +300,8 @@ int do_open(const char *pathname, int flags, mode_t mode)
 		flags |= O_NOATIME;
 #endif
 
-	return open(pathname, flags | O_BINARY, mode);
+	fd = open(pathname, flags | O_BINARY, to_native_mode(mode));
+  return fd;
 }
 
 #ifdef HAVE_CHMOD
@@ -244,7 +316,7 @@ int do_chmod(const char *path, mode_t mode)
 	switch (switch_step) {
 #ifdef HAVE_LCHMOD
 	case 0:
-		if ((code = lchmod(path, mode & CHMOD_BITS)) == 0)
+		if ((code = lchmod(path, to_native_mode(mode & CHMOD_BITS))) == 0)
 			break;
 		if (errno == ENOSYS)
 			switch_step++;
@@ -256,7 +328,7 @@ int do_chmod(const char *path, mode_t mode)
 		if (S_ISLNK(mode)) {
 # if defined HAVE_SETATTRLIST
 			struct attrlist attrList;
-			uint32_t m = mode & CHMOD_BITS; /* manpage is wrong: not mode_t! */
+			uint32_t m = to_native_mode(mode & CHMOD_BITS); /* manpage is wrong: not mode_t! */
 
 			memset(&attrList, 0, sizeof attrList);
 			attrList.bitmapcount = ATTR_BIT_MAP_COUNT;
@@ -269,7 +341,7 @@ int do_chmod(const char *path, mode_t mode)
 			code = 1;
 # endif
 		} else
-			code = chmod(path, mode & CHMOD_BITS); /* DISCOURAGED FUNCTION */
+			code = chmod(path, to_native_mode(mode & CHMOD_BITS)); /* DISCOURAGED FUNCTION */
 		break;
 	}
 	if (code != 0 && (preserve_perms || preserve_executability))
@@ -324,7 +396,7 @@ int do_mkdir(char *path, mode_t mode)
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	trim_trailing_slashes(path);
-	return mkdir(path, mode);
+	return mkdir(path, to_native_mode(mode));
 }
 
 /* like mkstemp but forces permissions */
@@ -339,7 +411,7 @@ int do_mkstemp(char *template, mode_t perms)
 		int fd = mkstemp(template);
 		if (fd == -1)
 			return -1;
-		if (fchmod(fd, perms) != 0 && preserve_perms) {
+		if (fchmod(fd, to_native_mode(perms)) != 0 && preserve_perms) {
 			int errno_save = errno;
 			close(fd);
 			unlink(template);
@@ -347,7 +419,7 @@ int do_mkstemp(char *template, mode_t perms)
 			return -1;
 		}
 #if defined HAVE_SETMODE && O_BINARY
-		setmode(fd, O_BINARY);
+		setmode(fd, to_native_mode(O_BINARY));
 #endif
 		return fd;
 	}
@@ -358,6 +430,35 @@ int do_mkstemp(char *template, mode_t perms)
 #endif
 }
 
+#ifdef __MVS__
+int do_stat(const char *path, STRUCT_STAT *st)
+{
+        int rc = stat(path, st);
+        if (!rc) {
+             st->st_mode = to_linux_mode(st->st_mode);
+        }
+        return rc;
+}
+
+int do_lstat(const char *path, STRUCT_STAT *st)
+{
+        int rc = lstat(path, st);
+        if (!rc) {
+             st->st_mode = to_linux_mode(st->st_mode);
+        }
+        return rc;
+}
+
+int do_fstat(int fd, STRUCT_STAT *st)
+{
+        int rc = fstat(fd, st);
+        if (!rc) {
+             st->st_mode = to_linux_mode(st->st_mode);
+        }
+        return rc;
+}
+#else
+
 int do_stat(const char *path, STRUCT_STAT *st)
 {
 #ifdef USE_STAT64_FUNCS
@@ -389,6 +490,8 @@ int do_fstat(int fd, STRUCT_STAT *st)
 #endif
 }
 
+#endif
+
 OFF_T do_lseek(int fd, OFF_T offset, int whence)
 {
 #ifdef HAVE_LSEEK64
